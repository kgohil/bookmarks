Coursera
========
* [Scala Spark Big Data](https://www.coursera.org/learn/scala-spark-big-data/)
  * 2017.06.02
    * [Datasets](https://www.coursera.org/learn/scala-spark-big-data/lecture/yrfPh/datasets)
    * [DataFrames (2)](https://www.coursera.org/learn/scala-spark-big-data/lecture/fwdAz/dataframes-2)
  * 2017.06.01
    * [DataFrames (1)](https://www.coursera.org/learn/scala-spark-big-data/lecture/3U9UW/dataframes-1)
    * [Spark SQL](https://www.coursera.org/learn/scala-spark-big-data/lecture/NlNqx/spark-sql)
  * 2017.05.30
    * [Structured vs Unstructured Data](https://www.coursera.org/learn/scala-spark-big-data/lecture/0RQHq/structured-vs-unstructured-data)
    * [Wide vs Narrow Dependencies](https://www.coursera.org/learn/scala-spark-big-data/lecture/shGAX/wide-vs-narrow-dependencies)
    * [Optimizing with Partitioners](https://www.coursera.org/learn/scala-spark-big-data/lecture/LQT67/optimizing-with-partitioners)
  * 2017.05.25
    * [Partitioning](https://www.coursera.org/learn/scala-spark-big-data/lecture/Vkhm0/partitioning)
  * 2017.05.24
    * [Shuffling: What it is and why it's important](https://www.coursera.org/learn/scala-spark-big-data/lecture/bT1YR/shuffling-what-it-is-and-why-its-important)
  * 2017.05.16
    * [Joins](https://www.coursera.org/learn/scala-spark-big-data/lecture/BWWvQ/joins)
    * [Transformations and Actions on Pair RDDs](https://www.coursera.org/learn/scala-spark-big-data/lecture/YV3BH/transformations-and-actions-on-pair-rdds)
    * [Pair RDDs](https://www.coursera.org/learn/scala-spark-big-data/lecture/d5gwX/pair-rdds)
  * 2017.05.15
    * [Reduction Operations](https://www.coursera.org/learn/scala-spark-big-data/lecture/GssIT/reduction-operations)
  * 2017.05.12
    * [Cluster Topology Matters!](https://www.coursera.org/learn/scala-spark-big-data/lecture/MORSy/cluster-topology-matters)
    * [Evaluation in Spark: Unlike Scala Collections!](https://www.coursera.org/learn/scala-spark-big-data/lecture/0GZV7/evaluation-in-spark-unlike-scala-collections)
      * cache(); default storage level, persist(); can be customized
      * the deferred semantics of RDDs are unlike Scala Collections
    * [RDDs: Transformation and Actions](https://www.coursera.org/learn/scala-spark-big-data/lecture/pYuxD/rdds-transformation-and-actions)
      * Transformer, Accessor in Scala > Transformation(lazy), Action(eager) in Spark
      * Transformation; map, flatMap, filter, distinct. return RDD
      * Action; collect, count, take, reduce, foreach
      * Transformations on Two RDDs; union, intersection, subtract, cartesian
      * other Actions; takeSample, takeOrdered, saveAsTextFile, saveAsSequenceFile
    * [RDDs, Spark's Distributed Collection](https://www.coursera.org/learn/scala-spark-big-data/lecture/Ztizq/rdds-sparks-distributed-collection)
  * 2017.05.11
    * [Latency](https://www.coursera.org/learn/scala-spark-big-data/lecture/D5o7O/latency)
      * Important Latency Numbers [Latency Numbers Every Programmer Should Know](https://gist.github.com/hyunjun/845cf3149d0021d882e753e5ac05c08e)
    * [Data-Parallel to Distributed Data-Parallel](https://www.coursera.org/learn/scala-spark-big-data/lecture/SWOCr/data-parallel-to-distributed-data-parallel)
      * Shared memory vs. Distributed data parallelism
      * Distributed data parallelism; worry about network latency between workers
    * [Introduction, Logistics, What You'll Learn](https://www.coursera.org/learn/scala-spark-big-data/lecture/io6qQ/introduction-logistics-what-you-ll-learn)
      * [community.cloud.databricks.com](https://community.cloud.databricks.com) 매우 느림
* [Parallel programming](https://www.coursera.org/learn/parprog1) 마틴 오더스키가 아니라 다른 사람
  * 2017.04.28
    * [Conc-Tree Combiners(https://www.coursera.org/learn/parprog1/lecture/Gggrf/conc-tree-combiners)
    * [Amortized, Constant-time Append Operation](https://www.coursera.org/learn/parprog1/lecture/TH4HC/amortized-constant-time-append-operation)
    * [Conc-tree Data Structure](https://www.coursera.org/learn/parprog1/lecture/85Rfr/conc-tree-data-structure)
    * [Parallel Two-phase Construction](https://www.coursera.org/learn/parprog1/lecture/4Yabo/parallel-two-phase-construction)
    * [Implementing Combiners](https://www.coursera.org/learn/parprog1/lecture/dB4xX/implementing-combiners)
  * 2017.04.27
    * [Splitters and Combiners](https://www.coursera.org/learn/parprog1/lecture/FdEvs/splitters-and-combiners)
  * 2017.04.26
    * [Scala Parallel Collections](https://www.coursera.org/learn/parprog1/lecture/Udyw6/scala-parallel-collections)
    * [Data-Parallel Operations II](https://www.coursera.org/learn/parprog1/lecture/shwKn/data-parallel-operations-ii)
    * [Data-Parallel Operations I](https://www.coursera.org/learn/parprog1/lecture/efzVT/data-parallel-operations-i)
    * [Data-Parallel Programming](https://www.coursera.org/learn/parprog1/lecture/vOFRq/data-parallel-programming)
  * 2017.04.20
    * [Parallel Scan (Prefix Sum) Operation](https://www.coursera.org/learn/parprog1/lecture/934xD/parallel-scan-prefix-sum-operation)
  * 2017.04.19
    * [Associativity II](https://www.coursera.org/learn/parprog1/lecture/anEPt/associativity-ii)
    * [Associativity I](https://www.coursera.org/learn/parprog1/lecture/tEU32/associativity-i)
      * associative, commutative와 map, reduce의 관계
  * 2017.04.18
    * [Parallel Fold (Reduce) Operation](https://www.coursera.org/learn/parprog1/lecture/LRUQt/parallel-fold-reduce-operation)
  * 2017.04.17
    * [Data Operations and Parallel Mapping](https://www.coursera.org/learn/parprog1/lecture/NTdxu/data-operations-and-parallel-mapping?)
  * 2017.04.14
    * [Parallel Sorting](https://www.coursera.org/learn/parprog1/lecture/iKwa2/parallel-sorting)
  * 2017.03.24
    * [Benchmarking Parallel Programs](https://www.coursera.org/learn/parprog1/lecture/cnI7T/benchmarking-parallel-programs)
      * test vs. benchmark
      * scalameter, IntelliJ에서는 안 되는 건가? 아니면 scala notebook에서 안 되나?
    * [How Fast are Parallel Programs?](https://www.coursera.org/learn/parprog1/lecture/OjNsc/how-fast-are-parallel-programs)
      * time complexity 계산 및 비교 방법
    * [First-Class Tasks](https://www.coursera.org/learn/parprog1/lecture/8kYAx/first-class-tasks)
      * (주제와는 무관) implicit 사용법
    * [Monte Carlo Method to Estimate Pi](https://www.coursera.org/learn/parprog1/lecture/Zgm76/monte-carlo-method-to-estimate-pi)
    * [Running Computations in Parallel](https://www.coursera.org/learn/parprog1/lecture/xMIfu/running-computations-in-parallel)
  * 2017.03.23
    * [Parallelism on the JVM II](https://www.coursera.org/learn/parprog1/lecture/TqQiO/parallelism-on-the-jvm-ii)
      * synchronized, deadlock, memory model
    * [Parallelism on the JVM I](https://www.coursera.org/learn/parprog1/lecture/muTSN/parallelism-on-the-jvm-i)
      * process, thread
      * atomic, synchronized, monitor
    * [Introduction to Parallel Computing](https://www.coursera.org/learn/parprog1/lecture/zNrIS/introduction-to-parallel-computing)
      * Parallel
        * speed up
        * division into subproblems
        * optimal use of parallel hardware
        * different granularity levels (bit, instruction, task)
      * Concurrent
        * convenience
        * when can an execution start?
        * how can information exchange occur?
        * how to manage access to shared resources?
* [Functional Program Design in Scala](https://www.coursera.org/learn/progfun2)
  * 2017.03.22 모르겠음 -\_-;
    * [Lecture 4.10 - Composing Futures 2](https://www.coursera.org/learn/progfun2/lecture/ItDNT/lecture-4-10-composing-futures-2)
      * foldLeft, foldRight에 대한 설명만 유일하게 알아듣겠음...
    * [Lecture 4.9 - Implementation of flatMap on Future](https://www.coursera.org/learn/progfun2/lecture/G3G6n/lecture-4-9-implementation-of-flatmap-on-future)
      * 배치가 왜 이럼... 갑자기 다시 마틴 오더스키 나오고 그 다음은 다시 에릭 마이어
    * [Lecture 4.8 - Composing Futures 1](https://www.coursera.org/learn/progfun2/lecture/ahhwl/lecture-4-8-composing-futures-1)
    * [Lecture 4.7 - Combinators on Futures 2](https://www.coursera.org/learn/progfun2/lecture/3DRhS/lecture-4-7-combinators-on-futures-2)
    * [Lecture 4.6 - Combinators on Futures 1](https://www.coursera.org/learn/progfun2/lecture/Ux37y/lecture-4-6-combinators-on-futures-1)
  * 2017.03.21
    * [Lecture 4.5 - Latency as an Effect 2](https://www.coursera.org/learn/progfun2/lecture/LTHTJ/lecture-4-5-latency-as-an-effect-2)
      * 모르겠다 -_-;
    * [Lecture 4.4 - Latency as an Effect 1](https://www.coursera.org/learn/progfun2/lecture/D569Q/lecture-4-4-latency-as-an-effect-1)
      * 갑자기 에릭 마이어가 나와서... 연결이 잘 안되는 다른 강의 내용을 하는 거 같음 -_-;
    * [Lecture 4.3 - A Simple FRP Implementation](https://www.coursera.org/learn/progfun2/lecture/5lWVa/lecture-4-3-a-simple-frp-implementation)
  * 2017.03.20
    * [Lecture 4.2 - Functional Reactive Programming](https://www.coursera.org/learn/progfun2/lecture/pEsTy/lecture-4-2-functional-reactive-programming)
      * 예제를 따라하는 데 또 오류 발생. `error: not found: value Var`
    * [Lecture 4.1 - Imperative Event Handling: The Observer Pattern](https://www.coursera.org/learn/progfun2/lecture/ZmLWH/lecture-4-1-imperative-event-handling-the-observer-pattern)
      * 예제를 따라하는 데 또 오류 발생
  * 2017.03.16
    * [Lecture 3.6 - Discrete Event Simulation: Implementation and Test](https://www.coursera.org/learn/progfun2/lecture/62Xed/lecture-3-6-discrete-event-simulation-implementation-and-test)
      * 강의 하면서 code 쓰는 게 많은데, eclipse에 쓰는 code와 강의 교재의 code가 조금 달라 따라가기 매우 불편함
    * [Lecture 3.5 - Discrete Event Simulation: API and Usage](https://www.coursera.org/learn/progfun2/lecture/WFKfD/lecture-3-5-discrete-event-simulation-api-and-usage)
    * [Lecture 3.4 - Extended Example: Discrete Event Simulation](https://www.coursera.org/learn/progfun2/lecture/FfnDK/lecture-3-4-extended-example-discrete-event-simulation)
    * [Lecture 3.3 - Loops](https://www.coursera.org/learn/progfun2/lecture/gUDmc/lecture-3-3-loops)
    * [Lecture 3.2 - Identity and Change](https://www.coursera.org/learn/progfun2/lecture/Z0j9P/lecture-3-2-identity-and-change)
    * [Lecture 3.1 - Functions and State](https://www.coursera.org/learn/progfun2/lecture/Gd31A/lecture-3-1-functions-and-state)
  * 2017.03.08
    * [Lecture 2.5 - Case Study: the Water Pouring Problem](https://www.coursera.org/learn/progfun2/lecture/EkEqR/lecture-2-5-case-study-the-water-pouring-problem)
      * @.@
    * [Lecture 2.4 - Computing with Infinite Sequences](https://www.coursera.org/learn/progfun2/lecture/0O7DM/lecture-2-4-computing-with-infinite-sequences)
    * [Lecture 2.3 - Lazy Evaluation](https://www.coursera.org/learn/progfun2/lecture/j6yMA/lecture-2-3-lazy-evaluation)
  * 2017.03.07
    * [Lecture 2.2 - Streams](https://www.coursera.org/learn/progfun2/lecture/Hq4hg/lecture-2-2-streams)
    * [Lecture 2.1 - Structural Induction on Trees](https://www.coursera.org/learn/progfun2/lecture/nEmOA/lecture-2-1-structural-induction-on-trees)
      * @.@
  * 2017.02.28
    * [Lecture 1.4 - Monads](https://www.coursera.org/learn/progfun2/lecture/98tNE/lecture-1-4-monads)
      * 예상한대로 어려움
    * [Lecture 1.3 - Functional Random Generators](https://www.coursera.org/learn/progfun2/lecture/S7NQA/lecture-1-3-functional-random-generators)
      * java의 Random을 사용해 다양한 data structure의 random instance 생성
    * [Lecture 1.2 - Translation of For](https://www.coursera.org/learn/progfun2/lecture/zJcCG/lecture-1-2-translation-of-for)
      * recap 두 번째 강의에서 나왔던 for-expression == map, flatMap, filter
      * 강의의 코드가 동작 안 하는게 있음. 뭐가 잘못일까?
    * [Lecture 1.1 - Queries with For](https://www.coursera.org/learn/progfun2/lecture/CRzdu/lecture-1-1-queries-with-for)
      * `{ for { ... } yield ... }.distinct`
  * 2017.02.24
    * **[Recap: Collections](https://www.coursera.org/learn/progfun2/lecture/apcY8/recap-collections)**
      * Idealized map, flatMap, filter 설명, Translation of For(for-expression == map or flatMap)
    * [Recap: Functions and Pattern Matching](https://www.coursera.org/learn/progfun2/lecture/zsnJ0/recap-functions-and-pattern-matching)
      * PartialFunction은 가장 바깥 pattern만 match
* [Functional Programming Principles in Scala](https://www.coursera.org/learn/progfun1)
  * 2017.02.01
    * [Programming Assignment: anagrams](https://www.coursera.org/learn/progfun1/programming/nVRPb/anagrams)
    * [conclusion](https://www.coursera.org/learn/progfun1/lecture/fgJcZ/conclusion)
    * [lecture-6-5-putting-the-pieces-together](https://www.coursera.org/learn/progfun1/lecture/5vUiM/lecture-6-5-putting-the-pieces-together)
      * 강의에서 사용하는 url이 있는데, 길어서 잘려서 구글에서 찾아봤는데, 예제로 사용된 것과 다른지 결과에 문제가 발생
    * [lecture-6-4-maps](https://www.coursera.org/learn/progfun1/lecture/weqsE/lecture-6-4-maps)
      * Map, Option, sorted, groupBy, withDefaultValue, repeated parameters
    * [lecture-6-3-combinatorial-search-example](https://www.coursera.org/learn/progfun1/lecture/H3cKk/lecture-6-3-combinatorial-search-example)
      * Sets, N-Queens problem
  * 2017.01.31
    * [lecture-6-2-combinatorial-search-and-for-expressions](https://www.coursera.org/learn/progfun1/lecture/JIPKx/lecture-6-2-combinatorial-search-and-for-expressions)
      * IndexedSeq, For-Expression
    * [lecture-6-1-other-collections](https://www.coursera.org/learn/progfun1/lecture/d0fdt/lecture-6-1-other-collections)
      * Vector, Array, String, Range, Seq operations
    * [lecture-5-7-a-larger-equational-proof-on-lists](https://www.coursera.org/learn/progfun1/lecture/6U42a/lecture-5-7-a-larger-equational-proof-on-lists)
      * 어려움
    * [lecture-5-6-reasoning-about-concat](https://www.coursera.org/learn/progfun1/lecture/5scUh/lecture-5-6-reasoning-about-concat)
      * reasoning, structural induction, 어려움
    * [lecture-5-5-reduction-of-lists](https://www.coursera.org/learn/progfun1/lecture/UpWlj/lecture-5-5-reduction-of-lists)
      * reduceLeft, foldLeft; left skewed tree를 그리면 이해하기 쉬움
      * reduceRight, foldRight; right skewed tree를 그리면 이해하기 쉬움
    * [lecture-5-4-higher-order-list-functions](https://www.coursera.org/learn/progfun1/lecture/UWSpZ/lecture-5-4-higher-order-list-functions)
    * [lecture-5-3-implicit-parameters](https://www.coursera.org/learn/progfun1/lecture/82wi4/lecture-5-3-implicit-parameters)
    * [lecture-5-2-pairs-and-tuples](https://www.coursera.org/learn/progfun1/lecture/0uFfe/lecture-5-2-pairs-and-tuples)
    * [lecture-5-1-more-functions-on-lists](https://www.coursera.org/learn/progfun1/lecture/XYlER/lecture-5-1-more-functions-on-lists)
      * list api function 설명. 여전히 intelliJ 문제 발생
  * 2017.01.25
    * [Programming Assignment: Huffman Coding](https://www.coursera.org/learn/progfun1/programming/uctOq/huffman-coding)
      * 잘 안되는 중...
  * 2017.01.24
    * [Programming Assignment: Huffman Coding](https://www.coursera.org/learn/progfun1/programming/uctOq/huffman-coding)
      * 우선 간단한 몇 가지만 시작
    * [lecture-4-7-lists](https://www.coursera.org/learn/progfun1/lecture/TFjsY/lecture-4-7-lists)
      * list 관련 내용이라 그나마 편하게 들었지만, intelliJ 오류 때문에 계속 예제 일부가 실행이 안 되는 경우가 발생
    * [lecture-4-6-pattern-matching](https://www.coursera.org/learn/progfun1/lecture/cdHAM/lecture-4-6-pattern-matching)
    * [lecture-4-5-decomposition](https://www.coursera.org/learn/progfun1/lecture/8ZaPo/lecture-4-5-decomposition)
      * 예제에 오류가 발생해서 실행할 수가 없음(아마 설명이 부족해서 뭔가 잘못했겠지만...) > 멍청하게 new를 빼먹음
      * trait와 class를 통해 object-oriented decomposition의 한계 설명
  * 2017.01.23
    * [lecture-4-4-variance-optional](https://www.coursera.org/learn/progfun1/lecture/dnreZ/lecture-4-4-variance-optional)
      * 여전히 이해 안 됨
      * 바뻐서 잠시 쉬었더니 어느 새 그동안 벌어놨던 거 다 까먹었음
  * 2017.01.17
    * [lecture-4-4-variance-optional](https://www.coursera.org/learn/progfun1/lecture/dnreZ/lecture-4-4-variance-optional)
      * covariant, contravariant, nonvariant... 조금 알 거 같았는데, 다시 생각해보니 착각이었던 듯 ㅜㅜ
  * 2017.01.16
    * [lecture-4-3-subtyping-and-generics](https://www.coursera.org/learn/progfun1/lecture/KvSC2/lecture-4-3-subtyping-and-generics)
      * 드디어 등장한 covariant
  * 2017.01.12
    * [lecture-4-2-functions-as-objects](https://www.coursera.org/learn/progfun1/lecture/n2EWV/lecture-4-2-functions-as-objects)
    * [lecture-4-1-objects-everywhere](https://www.coursera.org/learn/progfun1/lecture/gK7io/lecture-4-1-objects-everywhere)
  * 2017.01.10
    * Programming Assignment [object-oriented-sets](https://www.coursera.org/learn/progfun1/programming/Ogg05/object-oriented-sets)
      * 쉽지 않음. 우선 union 하나 해봤는데 (딴 짓 하면서 하긴 했지만) 거의 한 시간 가까이 걸림
      * 9.98 / 10; 0.02는 1 warning으로 감점
  * 2017.01.09
    * [lecture-3-2-how-classes-are-organized](https://www.coursera.org/learn/progfun1/lecture/YDsaZ/lecture-3-2-how-classes-are-organized)
      * package, type, exception
    * [lecture-3-3-polymorphism](https://www.coursera.org/learn/progfun1/lecture/HH19P/lecture-3-3-polymorphism)
      * polymorphism, Cons, Nil, type parameter
      * scala worksheet에서 custom class(Cons, Nil)이 import가 되지 않았는데, auto-import를 활성화하고 해결
        * 검색해보면 SBT plugin에서 'Make Project'를 활성화하라는 문서를 볼 수 있지만, 정작 'Make Project'를 찾을 수 없었음
  * 2017.01.06
    * [lecture-3-1-class-hierarchies](https://www.coursera.org/learn/progfun1/lecture/sqr2n/lecture-3-1-class-hierarchies)
      * abstract class
  * 2017.01.05
    * class 설명
      * [lecture-2-5-functions-and-data](https://www.coursera.org/learn/progfun1/lecture/5mmJP/lecture-2-5-functions-and-data)
        * 이 강의에서는 week2인데, 녹화된 강의는 예전에 week3에서 했던 거라 package가 다름
      * [lecture-2-6-more-fun-with-rationals](https://www.coursera.org/learn/progfun1/lecture/TIIQj/lecture-2-6-more-fun-with-rationals)
      * [lecture-2-7-evaluation-and-operators](https://www.coursera.org/learn/progfun1/lecture/6WD2X/lecture-2-7-evaluation-and-operators)
    * Programming Assignment [functional-sets](https://www.coursera.org/learn/progfun1/programming/BVa6a/functional-sets)
      * 8.98 / 10.00; test 점수가 7.00 / 8.00
  * 2017.01.04
    * [Programming Assignment: Recursion](https://www.coursera.org/learn/progfun1/programming/Ey6Jf/recursion)
      * week1 숙제 통과. 문제 자체는 간단한 건데, recursion을 immutable로 하는게 생각처럼 잘 되지가 않음
      * 마음에 들지 않던 코드를 조금 고쳐 다시 submit. token은 시간이 지나면 다시 생성해야 함
      * 두 번 다 점수는 9.98 / 10.00. 감점 0.02점은 code style 문제
    * [lecture-2-1-higher-order-functions](https://www.coursera.org/learn/progfun1/lecture/xuM1M/lecture-2-1-higher-order-functions)
    * [lecture-2-2-currying](https://www.coursera.org/learn/progfun1/lecture/fOuQ9/lecture-2-2-currying)
    * [lecture-2-3-example-finding-fixed-points](https://www.coursera.org/learn/progfun1/lecture/zj5Mt/lecture-2-3-example-finding-fixed-points)
    * [lecture-2-4-scala-syntax-summary](https://www.coursera.org/learn/progfun1/lecture/0AMxq/lecture-2-4-scala-syntax-summary)
  * 2017.01.03; 강의 1-6, 1-7
  * 2016.12.30
    * 강의
      * 자막이 있지만, 자막을 사람이 입력한 게 아니라, 음성에서 자동 변환한 거라 정확하지는 않다는 점 주의
      * 자막이 강의 자료 하단을 가려서 자막을 아예 꺼버림
      * 접속이 불량할 때 video를 받아 보려고 했는데, 맞게 다운이 되지만, 파일이름이 강의 이름이 아니라 index.mp4로 받아져서 여러 개를 받으면 수작업으로 이름을 고쳐줘야 함
      * 강의 중간에 나오는 quiz가 submit & continue와 그냥 continue button만 있는 두 가지가 있는데, 후자에서 submit을 하라는 오류가 발생하는 경우가 있음
      * 속도가 느림. 자동으로 다음 강의로 갈 때 끊어지는 경우가 많고, 화질을 바꿔도 끊기는 경우가 많음
      * intelliJ 괜히 업데이트 했다가 오류 발생(error while importing sbt project)해서 시간 낭비 ㅜㅜ
  * 2016.12.29
    * 시스템
      * certificate을 위해서는 ID와 얼굴 사진을 올려야 하는데 느리고 귀찮음
      * course 3개의 session을 모두 똑같이 1/2에 시작하는 걸로 했다가 두 개를 첫 번째 course가 끝난 후로 바꾸려고 채팅으로 상담을 했는데, 좀 시간이 걸렸지만, 해결이 됨
      * 아무튼 Parallel Programming은 가장 늦은 게 3/13에 시작하는 건데, Functional Programming Design in Scala가 4/3에 끝나기 때문에 나중에 다시 switch session을 해야 할 듯
    * 강의
      * 첫 번째 강의 introduction을 들었는데, 자막이 음성과 싱크가 맞지 않는 등, 오히려 예전에 비해 불편하고 시스템이 더 안 좋아진 느낌 -_-a
      * 첫 번째 intelliJ로 Example만드는 걸 듣는데, scala worksheet을 만드는 부분이 없어서 어떡하나 하다가 Project 이름(최상단 Example에서 마우스 오른쪽 버튼 누르고 나오는 메뉴에서 Make module 'example'을 선택하니 필요한 구조가 만들어지고, 거기서 scala worksheet을 만들 수 있게 됨)
    * [example assignment](https://www.coursera.org/learn/progfun1/programming/xIz9O/example-assignment)
      * 첫 번째 숙제 통과. scalatest에서 exception catch하는 방법을 잘 모르겠음
  * 2016.12.28; 5개의 코스로 구성된 과정인데, 각 코스로 연결하는 링크가 직관적이지 않고 불편함
